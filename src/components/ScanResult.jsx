import React, { useState } from "react";
import jsPDF from "jspdf";
import html2canvas from "html2canvas";

function Pill({ verdict }) {
  const color =
    verdict === "CONFIRMED"
      ? "pill-green"
      : verdict === "PARTIAL"
      ? "pill-yellow"
      : "pill-red";

  return <span className={`pill ${color}`}>{verdict}</span>;
}

function ScoreCircle({ score }) {
  const getScoreColor = (score) => {
    if (score >= 70) return "#4ade80"; // green
    if (score >= 50) return "#fbbf24"; // yellow
    if (score >= 30) return "#f97316"; // orange
    return "#ef4444"; // red
  };

  const circumference = 2 * Math.PI * 45;
  const offset = circumference - (score / 100) * circumference;

  return (
    <div className="score-circle-container">
      <svg className="score-circle" viewBox="0 0 100 100">
        <circle
          className="score-circle-bg"
          cx="50"
          cy="50"
          r="45"
          fill="none"
          stroke="#2a2a2a"
          strokeWidth="8"
        />
        <circle
          className="score-circle-progress"
          cx="50"
          cy="50"
          r="45"
          fill="none"
          stroke={getScoreColor(score)}
          strokeWidth="8"
          strokeDasharray={circumference}
          strokeDashoffset={offset}
          strokeLinecap="round"
          transform="rotate(-90 50 50)"
        />
      </svg>
      <div className="score-text">
        <span className="score-number">{score}</span>
        <span className="score-label">/100</span>
      </div>
    </div>
  );
}

function ScanResult({ result }) {
  const {
    tokenName,
    symbol,
    contractAddress,
    narrativeClaim,
    verdict,
    verdictReasoning,
    notesForUser,
    projectSummary,
    entities,
    cached,
    marketData,
    socials,
    securityData,
    confidence,
    sentimentScore,
    fundamentals,
    birdeye,
    tokenScore,
  } = result;

  const [copySuccess, setCopySuccess] = useState(false);
  const [downloadingPDF, setDownloadingPDF] = useState(false);

  const formatFullReport = () => {
    let report = `DYOR SCAN REPORT\n`;
    report += `${"=".repeat(50)}\n\n`;
    report += `TOKEN: ${tokenName || "Unknown Token"} (${symbol || "N/A"})\n`;
    report += `CONTRACT: ${contractAddress}\n`;
    report += `SCORE: ${tokenScore || 50}/100\n`;
    report += `VERDICT: ${verdict || "N/A"} (${confidence || "N/A"} confidence)\n`;
    report += `\n${"=".repeat(50)}\n\n`;

    report += `SUMMARY\n`;
    report += `${"-".repeat(50)}\n`;
    report += `${notesForUser || "No summary available."}\n\n`;

    if (marketData) {
      report += `MARKET DATA\n`;
      report += `${"-".repeat(50)}\n`;
      if (marketData.price) report += `Price: $${parseFloat(marketData.price).toFixed(8)}\n`;
      if (marketData.liquidity) report += `Liquidity: $${(marketData.liquidity / 1000000).toFixed(2)}M\n`;
      if (marketData.volume24h) report += `24h Volume: $${(marketData.volume24h / 1000000).toFixed(2)}M\n`;
      if (marketData.priceChange24h) report += `24h Change: ${marketData.priceChange24h >= 0 ? '+' : ''}${marketData.priceChange24h.toFixed(2)}%\n`;
      report += `\n`;
    }

    if (fundamentals) {
      report += `FUNDAMENTALS\n`;
      report += `${"-".repeat(50)}\n`;
      if (fundamentals.supply) report += `Supply: ${fundamentals.supply}\n`;
      if (fundamentals.holderCount) report += `Holders: ${fundamentals.holderCount}\n`;
      if (fundamentals.mintAuthority) report += `Mint Authority: ${fundamentals.mintAuthority}\n`;
      if (fundamentals.freezeAuthority) report += `Freeze Authority: ${fundamentals.freezeAuthority}\n`;
      report += `\n`;
    }

    report += `NARRATIVE CLAIM\n`;
    report += `${"-".repeat(50)}\n`;
    report += `${narrativeClaim || "No narrative extracted."}\n\n`;

    report += `VERDICT REASONING\n`;
    report += `${"-".repeat(50)}\n`;
    report += `${verdictReasoning || "No reasoning provided."}\n\n`;

    if (result.redFlags && result.redFlags.length > 0) {
      report += `CONCERNS\n`;
      report += `${"-".repeat(50)}\n`;
      result.redFlags.forEach((flag, idx) => {
        report += `${idx + 1}. ${flag}\n`;
      });
      report += `\n`;
    }

    if (entities?.topics && entities.topics.length > 0) {
      report += `RELATED TOPICS\n`;
      report += `${"-".repeat(50)}\n`;
      report += `${entities.topics.join(", ")}\n\n`;
    }

    report += `Generated by DYOR Scanner\n`;
    report += `${new Date().toISOString()}\n`;

    return report;
  };

  const handleCopyReport = async () => {
    try {
      const report = formatFullReport();
      await navigator.clipboard.writeText(report);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };

  const handleDownloadPDF = async () => {
    setDownloadingPDF(true);
    try {
      const element = document.querySelector('.scan-result');
      if (!element) {
        throw new Error("Report element not found");
      }

      const canvas = await html2canvas(element, {
        scale: 2,
        backgroundColor: '#0d0d0d',
        logging: false,
        useCORS: true,
        windowWidth: element.scrollWidth,
        windowHeight: element.scrollHeight,
      });
      
      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF('p', 'mm', 'a4');
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();
      
      const imgWidth = canvas.width;
      const imgHeight = canvas.height;
      const ratio = Math.min((pdfWidth - 20) / imgWidth, (pdfHeight - 20) / imgHeight);
      
      let heightLeft = imgHeight * ratio;
      let position = 10;
      
      pdf.addImage(imgData, 'PNG', 10, position, imgWidth * ratio, imgHeight * ratio);
      heightLeft -= (pdfHeight - 20);
      
      while (heightLeft > 0) {
        position = heightLeft - imgHeight * ratio + 10;
        pdf.addPage();
        pdf.addImage(imgData, 'PNG', 10, position, imgWidth * ratio, imgHeight * ratio);
        heightLeft -= (pdfHeight - 20);
      }
      
      const fileName = `${(tokenName || 'token').replace(/\s+/g, '_')}_${(symbol || 'scan').replace(/[^a-zA-Z0-9]/g, '')}_${new Date().toISOString().split('T')[0]}.pdf`;
      pdf.save(fileName);
      
      setTimeout(() => setDownloadingPDF(false), 1000);
    } catch (err) {
      console.error("Failed to generate PDF:", err);
      alert("Failed to generate PDF. Please try again.");
      setDownloadingPDF(false);
    }
  };

  // Parse summary into structured sections
  const parseSummary = (text) => {
    if (!text) return null;
    
    const sections = {
      about: "",
      fundamentals: "",
      assessment: "",
      insights: "",
    };
    
    // Try to extract structured parts (AI might format it)
    const aboutMatch = text.match(/(?:about|what the token|narrative|purpose)[^]*?(?=fundamentals|assessment|verdict|what to know|insights|$)/i);
    const fundamentalsMatch = text.match(/(?:fundamentals|holders|liquidity|security)[^]*?(?=assessment|verdict|what to know|insights|$)/i);
    const assessmentMatch = text.match(/(?:verdict|assessment|analysis|evaluation)[^]*?(?=what to know|insights|conclusion|$)/i);
    const insightsMatch = text.match(/(?:what to know|insights|implications|considerations)[^]*?$/i);
    
    if (aboutMatch) sections.about = aboutMatch[0].trim();
    if (fundamentalsMatch) sections.fundamentals = fundamentalsMatch[0].trim();
    if (assessmentMatch) sections.assessment = assessmentMatch[0].trim();
    if (insightsMatch) sections.insights = insightsMatch[0].trim();
    
    // If no structure found, use the whole text as about
    if (!sections.about && !sections.fundamentals) {
      sections.about = text;
    }
    
    return sections;
  };

  const summarySections = parseSummary(notesForUser);

  return (
    <section className="scan-result">
      <div className="result-header">
        <div className="result-header-main">
          <h2>
            {tokenName || "Unknown Token"} {symbol && <span className="symbol">({symbol})</span>}
          </h2>
          <p className="ca">{contractAddress}</p>
        </div>
        <div className="result-header-aside">
          {tokenScore !== undefined && tokenScore !== null && (
            <div className="score-display">
              <ScoreCircle score={tokenScore} />
              <span className="score-label-text">Overall Score</span>
            </div>
          )}
          <div className="verdict-block">
            {verdict && <Pill verdict={verdict} />}
            {cached && <span className="cached-tag">cached</span>}
          </div>
        </div>
      </div>

      <div className="result-actions">
        <button onClick={handleCopyReport} className="btn-copy-report">
          {copySuccess ? "‚úì Copied!" : "üìã Copy Report"}
        </button>
        <button onClick={handleDownloadPDF} className="btn-download-pdf" disabled={downloadingPDF}>
          {downloadingPDF ? "‚è≥ Generating..." : "üìÑ Download PDF"}
        </button>
      </div>

      {/* Structured Summary */}
      <div className="result-summary-section">
        <h3 className="summary-title">Summary</h3>
        <div className="summary-content">
          {summarySections ? (
            <>
              {summarySections.about && (
                <div className="summary-block">
                  <h4>About This Token</h4>
                  <p>{summarySections.about}</p>
                </div>
              )}
              {summarySections.fundamentals && (
                <div className="summary-block">
                  <h4>Fundamentals</h4>
                  <p>{summarySections.fundamentals}</p>
                </div>
              )}
              {summarySections.assessment && (
                <div className="summary-block">
                  <h4>Assessment</h4>
                  <p>{summarySections.assessment}</p>
                </div>
              )}
              {summarySections.insights && (
                <div className="summary-block">
                  <h4>What to Know</h4>
                  <p>{summarySections.insights}</p>
                </div>
              )}
            </>
          ) : (
            <p className="summary-text">{notesForUser || "No summary available."}</p>
          )}
        </div>
      </div>

      {/* Key Metrics Grid */}
      <div className="metrics-grid">
        {marketData?.price && (
          <div className="metric-card">
            <div className="metric-label">Price</div>
            <div className="metric-value">${parseFloat(marketData.price).toFixed(8)}</div>
          </div>
        )}
        {marketData?.liquidity && (
          <div className="metric-card">
            <div className="metric-label">Liquidity</div>
            <div className="metric-value">${(marketData.liquidity / 1000000).toFixed(2)}M</div>
          </div>
        )}
        {fundamentals?.holderCount && (
          <div className="metric-card">
            <div className="metric-label">Holders</div>
            <div className="metric-value">{fundamentals.holderCount.toLocaleString()}</div>
          </div>
        )}
        {marketData?.volume24h && (
          <div className="metric-card">
            <div className="metric-label">24h Volume</div>
            <div className="metric-value">${(marketData.volume24h / 1000000).toFixed(2)}M</div>
          </div>
        )}
        {marketData?.priceChange24h !== null && marketData?.priceChange24h !== undefined && (
          <div className="metric-card">
            <div className="metric-label">24h Change</div>
            <div className={`metric-value ${marketData.priceChange24h >= 0 ? 'positive' : 'negative'}`}>
              {marketData.priceChange24h >= 0 ? '+' : ''}{marketData.priceChange24h.toFixed(2)}%
            </div>
          </div>
        )}
        {sentimentScore !== null && sentimentScore !== undefined && (
          <div className="metric-card">
            <div className="metric-label">Sentiment</div>
            <div className="metric-value">{sentimentScore}/100</div>
          </div>
        )}
      </div>

      {/* Security Status */}
      {securityData && (
        <div className="result-section">
          <h3>Security Analysis</h3>
          {securityData.risks && securityData.risks.length > 0 ? (
            <div className="security-risks">
              {securityData.risks.map((risk, idx) => (
                <div key={idx} className="risk-item">
                  <span className={`risk-badge risk-${risk.level}`}>{risk.level}</span>
                  <span className="risk-description">{risk.description}</span>
                </div>
              ))}
            </div>
          ) : (
            <div className="security-good">
              <span className="check-icon">‚úì</span>
              <span>No significant security risks detected</span>
            </div>
          )}
          {fundamentals && (
            <div className="security-details">
              {fundamentals.mintAuthority === null && (
                <div className="security-detail good">
                  <span>‚úì</span> No mint authority (safe)
                </div>
              )}
              {fundamentals.freezeAuthority === null && (
                <div className="security-detail good">
                  <span>‚úì</span> No freeze authority (safe)
                </div>
              )}
              {fundamentals.mintAuthority && (
                <div className="security-detail warning">
                  <span>‚ö†</span> Has mint authority (can create new tokens)
                </div>
              )}
              {fundamentals.freezeAuthority && (
                <div className="security-detail warning">
                  <span>‚ö†</span> Has freeze authority (can freeze accounts)
                </div>
              )}
            </div>
          )}
        </div>
      )}

      {/* Narrative */}
      <div className="result-section">
        <h3>Narrative</h3>
        <p className="narrative-text">{narrativeClaim || "No narrative extracted yet."}</p>
      </div>

      {/* Detailed Analysis */}
      {verdictReasoning && (
        <div className="result-section">
          <h3>Detailed Analysis</h3>
          <p className="reasoning-text">{verdictReasoning}</p>
        </div>
      )}

      {/* Social Links */}
      {socials && (socials.website || socials.x || socials.telegram) && (
        <div className="result-section">
          <h3>Social Links</h3>
          <div className="socials-list">
            {socials.website && (
              <a href={socials.website} target="_blank" rel="noopener noreferrer" className="social-item">
                üåê Website
              </a>
            )}
            {socials.x && (
              <a href={socials.x} target="_blank" rel="noopener noreferrer" className="social-item">
                ùïè Twitter
              </a>
            )}
            {socials.telegram && (
              <a href={socials.telegram} target="_blank" rel="noopener noreferrer" className="social-item">
                üì± Telegram
              </a>
            )}
          </div>
        </div>
      )}

      {/* Topics */}
      {entities && entities.topics && entities.topics.length > 0 && (
        <div className="result-section">
          <h3>Related Topics</h3>
          <div className="topics-line">
            {entities.topics.map((topic, idx) => (
              <React.Fragment key={idx}>
                <span className="topic-item">{topic}</span>
                {idx < entities.topics.length - 1 && <span className="topic-separator">,</span>}
              </React.Fragment>
            ))}
          </div>
        </div>
      )}
    </section>
  );
}

export default ScanResult;
